\documentclass[10pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[dutch]{babel}
\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{wallpaper}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{parskip}
\usepackage{gensymb}

\usepackage{xcolor, colortbl}
\definecolor{ugentblue}{HTML}{164A7C}
\definecolor{gray}{HTML}{AAAAAA}
\definecolor{lightgray}{HTML}{FAFAFA}
\definecolor{grayborder}{HTML}{CCCCCC}
\definecolor{commentgreen}{HTML}{009900}

% Tables
\def\arraystretch{1.35}
\renewcommand{\tabularxcolumn}[1]{>{\small}m{#1}}
\newcommand{\hcell}[1]{
	\cellcolor{ugentblue}\color{white}\textbf{#1}
}

\makeatletter
\renewcommand\thesubsection{\@arabic\c@section.\@arabic\c@subsection}
\makeatother{}

\usepackage[hypertexnames=false]{hyperref}
\usepackage[numbered, depth=3]{bookmark}

\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
\fancyhf{}

\interfootnotelinepenalty=0

% Listings
\lstset{
	backgroundcolor=\color{lightgray},
	basicstyle=\footnotesize,
	commentstyle=\color{commentgreen},
	frame=single,
	framesep=7pt,
	keywordstyle=\color{blue},
	language=Java,
	numbers=none,
	numbersep=5pt,
	numberstyle=\tiny\color{gray},
	rulecolor=\color{gray},
	stepnumber=1,
	stringstyle=\color{ugentblue},
	showspaces=false,
	showstringspaces=false
}

\begin{document}
	\begin{titlepage}
		%% Footer
		\thispagestyle{fancy}
		\fancyhf{}

		%% Page
		\hfill
		\begin{minipage}[t][0.9\textheight]{0.8\textwidth}
			\noindent
			\includegraphics[width=55px]{ugent-blue.png} \\[-1em]
			\color{ugentblue}
			\makebox[0pt][l]{\rule{1.3\textwidth}{1pt}}
			\par
			\noindent
			\textbf{\textsf{Vage Databanken}} \textcolor{gray}{\textsf{Academiejaar 2014-2015}}
			\vfill
				\noindent
			{\huge \textsf{Project Vage Databanken}}
			\vskip\baselineskip
			\noindent
			\textsf{\textbf{Jasper D'haene} \\
				\textbf{Florian Dejonckheere}}
		\end{minipage}
	\end{titlepage}

	%%% PAGE STYLE %%%
	\nopagecolor
	\renewcommand{\footrulewidth}{0.4pt}
	\headheight 45pt
	\ULCornerWallPaper{1}{header.png}
	\fancyfoot[C]{\thepage}

	%%% DOCUMENT %%%
	\section{Generiek vaagregelsysteem}
		Beschrijving van het \texttt{FuzzySystem}. \\

		In het project werd gebruik gemaakt van de volgende extra libraries: de \href{https://commons.apache.org/proper/commons-math/}{Apache Commons Mathematics} library en de \href{https://code.google.com/p/json-simple/}{JSON.simple} library. De Apache Commons Math library voorziet een stabiele numerieke implementatie van verscheidene integratiemethoden. Omdat de integratieperformantie belangrijker is dan de precisie, werd gekozen voor de simpelste implementatie -- de \texttt{MidPointIntegrator} -- met een relatief kleine precisie.\\

		Alle parameters die de vorm van de lidmaatschapsfuncties bepalen zijn opgeslagen in de \texttt{resources} map, geserialiseerd in JSON. Deze bestanden worden ingelezen via de JSON.simple library en in het systeem ingevoerd aan de hand van de gegeven regels.\\

		Een probleem die al vroeg in de ontwikkeling voorkwam, betreft het onconditioneel limiteren van een aspect in de output. Stel dat er een conditie waarvoor onvoorwaardelijk moet gelden dat een outputvariabele nul is.

		\begin{lstlisting}
IF distanceFront IS minimal THEN acceleration IS none
		\end{lstlisting}

		Waarbij de lidmaatschapsfunctie van \texttt{acceleration IS none} een dunne clustering rond $0$ omvat. Deze regel kan zelfstandig niet worden uitgedrukt, aangezien het matchen van de conditie \texttt{distanceFront IS minimal} er niet met zekerheid voor zorgt dat het zwaartepunt van de resterende geaggregeerde lidmaatschapsfunctie op of onder $0$ terecht komt. Mogelijke oplossingen voor dit probleem zijn het combineren van elke regel die invloed heeft op \texttt{acceleration} met een \texttt{distanceFront IS minimal}-clausule, of een set equivalent, maar negatieve regels opstellen voor de positieve acceleratie-bepalende regels, zodat het zwaartepunt exact op $0$ valt. Beide oplossingen zijn omslachtig en onschaalbaar.\\

		Het systeem -- omvat in de \texttt{fuzzy/FuzzySystem} klasse -- wordt vooreerst leeg ge\"instantieerd, en daarna pas worden de regels opgegeven. Deze regels zijn intern opgeslagen in een \texttt{ArrayList}, waarover er ge\"itereerd wordt bij evaluatie. Deze regels hoeven slechts \'e\'enmaal ingevoerd te worden -- in de constructor van de controller (in casu zorgt de \texttt{BaseController} hiervoor).\\

		Daarnaast heeft het systeem ook een nood aan inputvariabelen en -waarden. Deze worden elke frame in de \texttt{getFrameControl()} methode ingevoerd. Intern worden de variabelen en hun bijbehorende waarden opgeslagen in een \texttt{HashMap}, gesorteerd op de naam van de variabele. Later kan dan de geaggregeerde lidmaatschapsfunctie bepaald worden uit een entry in de map. Vervolgens wordt het volledige systeem ge\"evalueerd aan de hand van \\

		Hoewel het opgegeven controlesysteem natively gebruik maakt van het \texttt{float} datatype, werd de keuze gemaakt om met \texttt{double} te werken, voornamelijk omdat de Apache Commons Math library als in- en outputtype \texttt{double} heeft.

	\section{Controllers}
		\subsection{SafeController}
			\texttt{SafeController} legt de focus op het zo veilig mogelijk bereiken van de finish. De grootste limiterende factor in deze controller is dan ook de snelheid. Door het ontwerp van het systeem wordt de snelheid gelimiteerd tot ongeveer 91 km/h. Als bijkomende constraints is er ook een minimumsnelheid opgelegd, alsook een remmende werking als de auto achteruit rijdt (bijvoorbeeld na een frontale botsing).

			De besturing van de wagen wordt geregeld door een set van regels die geleidelijk draaien onder invloed van de ligging van de wagen op het parcours. Die ligging wordt door de volgende formule berekend.

			\begin{equation}
	ratio = \frac{sensor_{left}}{sensor_{right}}
			\end{equation}

			Vervolgens wordt er bijgestuurd afhankelijk van de proportie. Deze methode heeft het voordeel ten opzichte van een simpele plaatsbepaling ($sensor_{left} - sensor_{right}$) dat de breedte van de weg minder invloed heeft op de koerscorrectie.\\
			De output van de functie (de \texttt{Consequence}) heeft als lidmaatschapsfunctie een S-curve. Op deze manier zal een kleine afwijking ($ratio \approx 1$) zeer weinig invloed hebben, die stijgt naar mate $ratio$ afwijkt van $1$. Er werd bewust voor gekozen de outputvariabele \texttt{steering} binnen het domein niet te hoog te laten worden, zodat er zich minder of geen bruuske bewegingen voordoen.

		\subsection{SpeedController}
			\texttt{SpeedController} zal trachten zo snel mogelijk de finish te bereiken. Hierbij wordt gebruik gemaakt van een uitgebreide versie van de snelheidsregels van \texttt{SafeController}. De granulariteit van deze regels is groter: er zijn meer regels vereist om de wagen een gecontroleerde snelheid mee te geven. Ook het remmen schaalt mee, aangezien er bij een groter aantal regels over een component ook een grotere controle over het complementaire aspect gevraagd wordt.\\

			Het koerscorrectie-algoritme uit \texttt{SafeController} werd ook aangepast. Bij lagere snelheden (onder 100 km/h) wordt het systeem uit \texttt{SafeController} gebruikt -- die geeft een distributie van ongeveer $\pm 0.17$ tot $\pm 0.44$ -- maar bij hogere snelheden kan een minder precieze of grote beweging catastrofale gevolgen hebben. Daarom ligt bij hogere snelheden de effectieve drempel hoger, en zijn de bewegingen preciezer.\\

			%% TODO: is dit wel zo?
			Ter slippreventie is er tenslotte nog een laatste regel van kracht: als er gedraaid moet worden ($ratio \not\approx 1$), treedt de rem ook in werking. Zo kan voorkomen worden dat er tegelijkertijd gedraaid en versneld wordt. \texttt{RallyController} breidt uit op dit concept.

		\subsection{RallyController}
			Beschrijving van de \texttt{RallyController}.

	\section{Performantie}
		\subsection{Keuze t-norm en t-conorm}
			%% Is de keuze van t-norm en t-conorm belangrijk voor de prestatie (i.e. de gemiddelde snelheid) van de wagen?

		\subsection{Robuustheid regelsysteem}
			%% Hoe robuust is uw regelsysteem voor verschillende races? Is de gemiddelde snelheid ongeveer dezelfde als u de wagen verschillende keren laat racen op een welbepaald parcours?

		\subsection{Minder performante parcours}
			%% Zijn er parcours waar uw controller minder goed presteert? Hoe komt dit?
			Sommige parcours -- zoals Spa Francorchamps en Interlagos -- hebben een bepaalde structuur die verraderlijke metingen kunnen geven. Scherpe bochten kunnen aanleiding geven tot foutieve metingen door de vooruitkijkende sensoren die voor de correcte sturing zorgen. In zo'n scherpe bocht kan het voorkomen dat de sensoren de fysieke bocht niet (voldoende) opmerken, en onmiddelijk een meting geven voor de wand tegenover de bocht. Hierdoor stijgt de $ratio$, maar niet voldoende om de wagen te corrigeren in de bocht. Dit effect wordt versterkt door grote snelheden.

			\begin{figure}[h]
				\centering
				\includegraphics[width=5cm]{sensors-corner.png}
				\caption{Foutieve meting bij scherpe bochten}
				\label{fig:sensors-corner}
			\end{figure}

			Op zich zou dit probleem verholpen kunnen worden door de hoek van de sensoren continu adaptief aan te passen -- zodat een scherpe bocht toch opgemerkt wordt -- ware het niet dat de outputvariabelen van een enkele iteratie geen (meetbare) invloed hebben op de volgende iteratie. Opnieuw kan dit probleem suboptimaal opgelost worden door het intelligent gebruik maken van \textit{dampening}, waarbij beslist wordt of de output van de huidige iteratie authoritatief wordt doorgevoerd, of dat de vorige iteratie er invloed op hebben. Een goede optimalisatie voor dit karakter is een lokale \textit{cache} van sensorwaarden, zodat bepaalde probleempatronen en obstakels gedetecteerd kunnen worden. Dit systeem valt echter niet in de scope van dit project en wordt dus ook enkel als gedachte-experiment aangehaald.\\

			Uiteindelijk werd gekozen om een vaste sensorhoek -- $scanAngle = 0.9 = 30 \degree$ -- te hanteren, bepaald uit empirische experimenten op verschillende parcours met verschillende controllers.

		\subsection{Veiligheid}
			%% Hoe veilig is uw wagen, i.e. hoe dikwijls crasht uw wagen?
			In dit model bestaat het concept \textit{veiligheid} enkel uit het contact met de wand, waardoor de \texttt{collisionSum} omhoog gaat. \texttt{SafeController} is ontworpen om zo veilig mogelijk de finish te bereiken


			%%% UITSLAG RITTEN %%%
			%% SafeController
			%%   Spa Francorchamps: crasht op de 45° bocht vlak voor de finish
			%%   Silverstone: geen problemen
			%%   Interlagos: geen problemen
			%%   Texas: geen problemen

			%% SpeedController
			%%   Spa Francorchamps: keert midden in het parcours 180°
			%%   Silverstone: geen problemen
			%%   Interlagos: hapert, maar geen problemen
			%%   Texas: draait 360°, maar corrigeert zichzelf

		\subsection{Exacte controller}
			%% Wat zijn de verschillen met een exacte controller (beter/slechter)?
			Een exacte controller reageert volgens welbepaalde scherpe grenzen op de input. Het grote verschil met deze systemen is dat er van een graduele aanpak geen sprake is. Bij een vaag regelsysteem kan de granulariteit van de response aangepast worden volgens constanten of andere (input-) parameters. Er kunnen meerdere regels zijn die betrekking hebben op \'e\'en aspect, en die dus elk tot op een bepaalde mate invloed hebben op de uitkomst van het systeem. \\

			Beschouw het volgende systeem met als output \texttt{acceleration}: Als er zich geen obstakels bevinden voor de auto, kan hij versnellen. Maar de versnelling moet gematigd zijn als de auto aan het driften is (dus als de laterale snelheid groter dan 0 is).
			Dit kan eenvoudig gemodelleerd worden door de volgende regels.

			\begin{lstlisting}
IF (distanceFront IS SMALL) THEN acceleration IS high
IF (lateralVelocity IS GREATER THAN ZERO) THEN acceleration IS low
			\end{lstlisting}

			Door het combineren van deze regels wordt in een drift rekening gehouden met zowel \texttt{acceleration IS high} en \texttt{acceleration IS low}, waardoor een gebalanceerd equilibrium uiteindelijk gekozen wordt als \texttt{acceleration}.
			Indien men dit in een exacte controller wil implementeren, moeten de twee regels gemultiplexd worden in \'e\'en formule. Dit kan bijvoorbeeld als volgt gebeuren.

			\begin{lstlisting}
int factor = 1;
if (lateralVelocity > 0)
	factor = 0.5;

return (1400 * (distanceFront / 200) * factor);
			\end{lstlisting}

			Deze formule bevat significant meer complexiteit en is ook sensitiever dan een vaagregelsysteem. Ook als er (foutieve) waarden optreden die buiten het definitiegebied vallen, kan de output een ongewenste waarde aannemen. Vage regelsystemen hebben hiertegen een intrinsieke bescherming, aangezien $\mu = 0$ buiten het definitiegebied van de lidmaatschapsfunctie.

		\section*{Eindopmerkingen}
			Het opgegeven systeem is inherent moeilijk te debuggen. De auto start altijd op dezelfde plaats, wat het lastig maakt om bugs in een later deel van het parcours te identificeren en corrigeren. Ook een vorm van temporele controle ontbreekt, waardoor bugtracking een passieve en tijdsintensieve activiteit wordt. Ook het gebrek aan sensoren maakt het detecteren van een catastrofale fout onmogelijk. Als de auto crasht met een voldoende grote snelheid, kan de physics engine ervoor zorgen dat deze uiteindelijk omgekeerd techtkomt. De controllers zijn zich niet bewust van deze ontwikkeling, en rijden na\"ief verder -- de verkeerde richting op.\\

			Ook is er een schijn van non-determinisme aanwezig, waardoor volgens het \href{https://en.wikipedia.org/wiki/Butterfly_effect}{butterfly-effect} elke beweging tot een compleet ander eindresultaat leidt. Daardoor is het ontwikkelen van een algemene controller -- die op alle parcours dezelfde acceptabele performantie heeft -- moeilijk tot zelfs onmogelijk.\\

			Hoewel een vaag regelsysteem uitstekend geschikt is voor het ontwerpen van praktische toepassingen zoals soft controllers, bevat het opgegeven systeem te weinig invoerdata om een acceptabel resultaat te produceren. Bepaalde situaties kunnen niet gemodelleerd en dus ook niet gedetecteerd en voorkomen worden. Voor bepaalde situaties -- zoals het gebruik van een adaptieve \texttt{scanAngle} -- kan een exact regelsysteem een goede oplossing bieden. De optimale oplossing is dan ook de gulden middenweg: een hybride combinatie van een vaag en een exact regelsysteem die ervoor zorgt dat de controller een gevarieerd gedrag bezit, en die intelligent rekening houdt met de omgeving en de in- en outputvariabelen.

\end{document}
